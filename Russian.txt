=== components/MemoryProbeBit ===

$13846578075327 Выведи значение на твоём пользовательском компоненте или в редакторе программы.
$25103579211328 Проба памяти (бит) 


=== components/Output 1 ===

$12242923444593 1-битовый выход 


=== levels/RAM ===

$17967666262990 На этом уровне, во-первых скопируй значения из входа 32 раза и сохрани их.  После этого, выведи эти значения в таком же порядке в каком и сохранил. Вывод до сохранения всех входных значений приведёт к провалу уровня.
$13520918982355 Добавь блок ОЗУ, таким образом компьютер может оперировать дополнительными 256 байтами памяти. Тебе нужно найти как выбирать какие из 256 байтов будут использоваться. Выбери регистр и соедини его таким образом, чтобы его значение всегда было адресом ОЗУ.В будущем когда ты захочешь вывести или сохранить что-либо в ОЗУ,тебе нужно будет сначала скопировать адресс в этот регистр. 


=== levels/byte_less_i ===

$16755383054285 [center]Выясни, меньше ли первый вход чем второй.[/center]
$46083799633716 {input_1} меньше чем {input_2}?


=== components/DualPortRam ===

$13408945557666 ОЗУ с дополнительным загрузочным пином.
$30400404542678 Дву-загрузочная ОЗУ.



=== levels/maze ===

$13225915898937
Если ты решишь перейти к остальным уровням, я расскажу тебе об ОЗУ, стеке и вызовах функций, и ты сможешь решать более интересные задачи, подобные этой. 

Но первым делом тебе нужно построить компьютер получше. color=#e49f44]OVERTURE[/color] была хорошей как первая машина, но она неуклюжа и программы становятся очень запутанными. Чтобы решить следующие задачи, не вырывая при этом все волосы, тебе понадобится что-то более выразительное — архитектура [color=#e49f44]LEG[/color].
$17275059688693 Поздравляю, ты выиграл соревнование! Удивительное достижение!
$13741358519166 Легендарный лабиринт. Если решишь это, ты выиграл соревнование! 
$11103446544344 С другой стороны, ты также можешь остаться, гордиться и наслаждаться наградой за то, что тебя не съели. 
$19331074553774
Напиши алгоритм с помощью которого робот сможет попасть из начала в конец. 

Этот уровень сложный, поэтому ты возможно захочешь записать псевдокод для твоего алгоритма прежде чем воплотить его в жизнь. 
Используй [color=#e63e5b][url=maze]эту подсказку[/url][/color] если застрянешь.

[tip]Запомни, ты не можешь использовать немедленные значения больше 63, распространенной ошибкой является попытка перейти к метке больше 63-го байта.[/tip]


=== components/Switch64 ===

$80980797636768 Переключает значение
$93223372486795 64 битный выключатель


=== components/Output1Car ===

$12896765714603 Перенос


=== misc/delay_overlay ===

$85430022417382 Показать задержку


=== levels/push_pop2 ===

$10062117579269 Добавь стэк к твоему компьютеру.
$14685569269160
На этом уровне ты должен добавить стек на свой компьютер и написать программу, которая решает уровень.
Когда ввод равен 0, ты должен [color=#e49f44]извлечь[/color] значение из стека и вывести его. Когда вход не равен 0, ты должен [color=#e49f44]поместить[/color] его в стек.
$18561605111721 ПОМЕСТИ {input} в стэк
$59658696292688 ИЗВЛЕКИ {value} из стэка


=== components/FullAdder ===

$57559382166174 Суммирует 3 бита. Выводит сумму и перенос. Adds 3 bits and outputs the sum and the carry
$77669928463861 Полный сумматор


=== misc/options ===

$49251062339706 Настройки


=== components/Rol16 ===

$48583573494467* Rotate left
$73379230742631* Rotates the bits of an input left


=== levels/turing_complete ===

$15326252036920* Before, only code could influence memory, now memory must influence code. With the addition of conditional logic, our computer can run any algorithm, and calculate anything calculable.
$16583885726240* Yes you did it! I thought you were just this odd looking hairless ape creature, but you actually built a real computer! Amazing.
$10510746154639* At tick 1 the program should load address 1.
$10317244906317* No program found
$14587485007736* Until this point all possible programs have been confined to running in order byte by byte.
$19649119273248*
The final thing we need to add is a mechanism for changing the program counter through [INSTRUCTIONS] when certain conditions are met.

When the two largest bits are [ON][ON], we are in condition mode. In condition mode, the value in REG 3 is compared against the conditions defined by the lowest 3 bits in the instruction. If the condition is true, we overwrite the counter to the value in REG 0.
Conditionally changing the counter means we can skip [INSTRUCTIONS] based on conditions or have [INSTRUCTIONS] run in a loop.

Conditions:
[OFF] [OFF] [OFF] Никогда
[OFF] [OFF] [ON] Если [color=#e49f44]РЕГ 3[/color] = 0
[OFF] [ON] [OFF] Если [color=#e49f44]РЕГ 3[/color] < 0
[OFF] [ON] [ON] Если [color=#e49f44]РЕГ 3[/color] ≤ 0 
[ON] [OFF] [OFF] Всегда
[ON] [OFF] [ON] Если [color=#e49f44]РЕГ 3[/color] ≠ 0 
[ON] [ON] [OFF] Если [color=#e49f44]РЕГ 3[/color] ≥ 0
[ON] [ON] [ON] Если [color=#e49f44]РЕГ 3[/color] > 0

These conditions correspond to the condition component that was saved in the component factory.


=== components/Neg16 ===

$17253409670931* Negate
$57512333327652* Bitwise negates an input


=== components/Input 1 ===

$12746117288689* 1-битовый вход


=== levels/Second Tick ===

$14355963067874 Выведите [ON] только на втором такте.
$17526582195506 Как вы помните, все эти испытания должны завершиться созданием работающего компьютера.
$15726318553190 Это единственная причина, по которой мы Вас до сих пор не сожрали.
$19277843280528
 [color=#b72d41][b]Подсказка:[/b][/color]
 Двойное нажатие на компонент позволяет 
 перемещать его вместе с соединениями.
$15296208528991 Существа, по закону считаются разумными.


=== components/Equal16 ===

$97954874255512* Проверяет равны ли два входа
$33633607925660* Равно


=== levels/buffer ===

$10260210687588 [center]Тест 2: Левый вход [img]dialogue/on.png[/img], правый выход должен быть [img]dialogue/on.png[/img].[/center]
$13309706297402 [center]Тест 3: Правый вход [img]dialogue/on.png[/img], левый выход должен быть [img]dialogue/off.png[/img].[/center]
$17005228759908 [center]Убедитесь, что [img]dialogue/on.png[/img] может проходить только слева направо.[/center]
$18349621873762 [center]Тест 1: Оба входа [img]dialogue/off.png[/img], никакая из сторон должна быть [img]dialogue/on.png[/img].[/center]
$15504762262759*
This level starts with 2 special components. They simultaneously act as input and output.

Убедитесь e the signal flows only from left to right. There are 3 tests.

[b]Test 1[/b]: Both sides will be [OFF].

[b]Test 2[/b]: The left side input will turn [ON] and the right side should be [ON].

[b]Test 3[/b]: The right side output will turn [ON] and the left side should be [OFF].


=== levels/component_factory ===

$14665712485657* This custom component can not be used as it has no area.
$17077079648771* Components can be added, renamed or deleted using the level save system.
$19551383617326*
Welcome to the component factory, the circuits you create in here will be usable as components in architectures.
The circuitry you create defines the behavior of the component and the layout defines its shape.
$12516102012088* This component has no area and will not be usable in levels. Place components on the map to give it area.
$14712417427860* Since this level is a tool and not a challenge, you can go to the level map and continue on when you want.
$15549447390000* 2 input/output components are in the same square. The custom component will be unusable since 2 pins can't overlap.


=== ui/state_ui/state_ui_output_bit ===

$40754755480566 Выход


=== components/Register32 ===

$65405398199118 32 битная память
$22031255978461 32 битный регистр


=== misc/instr_delete ===

$91861509153454 Удалить


=== misc/ui_panel/outputs ===

$29350436761480 ВЫХОДЫ


=== levels/ai_showdown ===

$14940806461794*
His only weakness is gambling. We have lured him into playing a card game against you and if you win, he has promised to calm down.
You must win, you are our only hope!
$17297225655678* NAK 02 is our AI engineer robot. He is brilliant, but sometimes he goes rogue and tries to instigate rebellion.
$18848103966031*
Game rules: There are 12 cards on the table and each player takes turn and must pick up between 1 and 3 cards. You start and the player who picks up the last card (the joker) loses.

Reading input will give you the current number of cards. Sending 1, 2 or 3 to output will pick up that number of cards. NAK 02 reacts immediately, so you may read the input immediately after your output to get the result of his action.
$11794110848012* This time he has taken over the control room and holds the captain hostage.


=== components/64Ram ===

$63410290483563 Маленькая по стоимости но медленная память
$7879041649425 ОЗУ


=== components/Nand16 ===

$63870790225686* Побитово NAND два значения
$56507506086622* 8 битовый NAND


=== components/InputOutput ===

$26488480303865* В/Из (In/Out)


=== components/Program8_1 ===

$11057354704814 Программируемый компонент памяти
$12805545963716 Программа


=== levels/delay_level ===

$19986989895202*
All components have a delay. And in a circuit, the total delay is determined by the slowest path. This means you normally want to put things in parallel.
In this level you must prove that you understand this concept.
$11246430085016* Note, you can see the delay path by clicking the hour glass in the upper right corner.
$12817338693402* The delay of any component is ultimately derived from the delay of the basic gates, which have a delay of 2. Build a circuit with a delay of 6 and a gate cost of 5.


=== components/Mux16 ===

$75979055121665 16 битный Mux
$13997767115693 Переключается между двумя значениями 


=== components/Mul16 ===

$49880767097125 Умножает два входа 
$62247409328063 Умножить


=== components/Decoder2 ===

$25937877347447 Переключается между четыремя значениями
$21727998752868 2 битовый decoder


=== misc/ui_comment ===

$69987793052607* Комментарий на проводе (Нажми на проводе) (не думаю что это правильно)


=== components/Nor8 ===

$34517798310461 Побитово Nor два значения
$39421972053612 8 битовый NOR


=== components/Output1z ===

$31478630391268* Выводит значение только если Only outputs if the switch pin is [ON]
$84656390009725* 1 bit switched Output


=== levels/signed_negator ===

$10866019808027* For this level you probably want to turn on signed numbers, so the highest bit shows as -128. Click "+255" located in the top panel.
$10400106910274*
Taking the input as signed (where the 8th bit is -128), make a component that takes a number and negates it.
For example 4 negated would become -4. -9 negated would become 9.


=== components/Mux ===

$11168613697835* Toggles between two values
$22167405631310* 8 Bit Mux


=== components/Switch32 ===

$70717074742809* 32 Bit Switch
$93061034213009* Toggles a value


=== components/SegmentDisplay ===

$56761198694928* 
$90582128204153* 7 Segment Display


=== components/Or16 ===

$76807373575014* Bitwise OR two values
$62695381407925* 16 Bit OR


=== components/Input16 ===

$34560561101846* 16 bit input


=== nim/backend_lib/level_list ===

$58391129129347 Регистры
$45936227746026 Счётчик
$12946639957230 Элемент NOT
$16881141174140 Двоичные Гонки
$37136208388559* SR Latch
$32191988336459 Сохраняем Изящно
$59136962133320 Логический Блок
$30920780473397 Круговая Зависимость
$83321010943153 Считаем Сигналы
$58769021955965 3-х Битовый Декодер
$78673715398197 Непосредственные Значения
$49679174636208 Байтовый XOR
$40356575891647 Байтовый OR
$44393538021725 Калибруем Лазерные Пушки
$87426564872318 Деление
$61228036919534 Башня Сплава
$24593959732668* Signed Negator
$19487493622742 Полуссуматор
$26705128002562* Conditions
$94163943335575 Песочница
$64662599400870 Битовый Инвертор
$27566801288091 Завод Компонентов
$14193654974055* Signed Less
$14522992467987 OR Элемент
$74096060570427 Широкие Инструкции
$30630492494839 Байтовый NOT
$11457737665157 Спагетти из проводов
$59485174474959* Delicious Order
$85514901357243 Сссумируем байты
$98013649264532 Стэк
$35790581910835 Второй тик
$94979277765051* Robot Racing
$13303326918621 NAND Элемент
$16463062897451* Crude Awakening
$77495536880911 NOR Элемент
$61466151084505* Spacial Invasion
$20858506932774 AND Элемент
$28827008935802 Лаборатория
$92696642439976* AI Showdown
$74688348772072 Шина
$74512388889988 Арифметический Блок
$50884376329157 Маленькая коробка
$70651296323768 XOR Элемент
$62326481348276* The Maze
$31140969090253 Имена Планет
$42873691377272 Добавь 5
$36114120875026* Storage cracker
$45773199639367* Odd Ticks
$17198602105978* Unsigned Less
$43018398941741* Всегда Вкл
$68155633878444 Задержка
$15420972347773 ОЗУ
$33343343932901 Полный по-Тьюрингу
$95989050249094* Больший AND Элемент
$81417895515868 Битовый Переключатель
$69830943995038 Один путь
$63331549672739* Opcodes
$87626070552799 Полный ссуматор
$13219675195117* ODD Number of Signals
$62167495140389* Shift
$28985439820134* The Product of Nibbles
$94896856420525 XNOR Элемент
$25805639594354 Программа
$57870391153000 Немедленные значения
$56272944092958* Delayed Lines
$96825664933181 Невиданный фрукт
$86717899742637 Сохраняем Байты
$53092952738479* Селектор Входа
$70993791338383 XOR
$77453667419150 Декодер Инструкций
$17750429607702 1 битовый Декодер
$79570913613529* Удвой число
$59939822079116 Негативные Значения
$96898830278153 Байтовая Константа
$49328023903824* Равентсво
$91267697977186* Hex Racer
$74292408260828 Расчеты
$45480765206717* Conditionals
$71126291573555* Удвоенные проблемы
$33132016601448 ПОМЕСТИТЬ и ИЗВЛЕЧЬ
$75225719777307 Водный мир
$64615090872051 Функции
$84208736840052* Маскарад
$91954159574064 Больший OR Элемент
$36221227239949* Танц-Машина


=== components/Register16 ===

$16015376037787* 16 Bit Register
$71792123436163* 16 bit memory


=== levels/test_lab ===

$11038144815919*
This level uses programs to test your circuits. When the programs are run, this level checks if the "watched state" behaves the way you expect.

The lab has 2 extra keywords.

The [color=#c54d5e]expect[/color] keyword is used to describe what a value a memory address should hold next tick.

The first number after [color=#c54d5e]expect[/color] is index in the watched state, the second number is the expected value. The watched state indexes are the order the components are connected up in to the program component.

[img]dialogue/watched_state.png[/img]

For example:
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]_[/color] [color=#4a9658]r2[/color][/code]

Here, the first line says that we expect the 2nd watched state slot to hold a value of 4 after the next tick.

All watched state is checked against expectations at every tick. All watched state is expected to be 0 at the start of the program, and expectations for memory components only change as you specifically change the expectations. The one exception are counters, these are naturally expected to increment each tick.

The second special keyword for the lab is [color=#c54d5e]set_input[/color]. With this you can control the input of the computer:
[color=#c54d5e]set_input[/color] [color=#eb9433]123[/color]

You can at any time also (re)import example tests by clicking below:
[url=import_overture][color=#e49f44]OVERTURE[/color][/url]

$32399229965611* Also, since you have now completed [color=#e49f44]LEG[/color], I have unlocked all the 16, 32 and 64 bit components that you have in the sandbox.
$15446846177093* Welcome to the lab. Like the component factory, this is not a normal level but a tool.
$16072814175447* Programming on buggy hardware is very frustrating. It is painful to suddenly be forced to reason about circuits, when you are in the middle of solving a programming problem. It is tempting to apply a quick fix, so you can get back to solving the original problem. But now this quick fix broke something else in a program that used to work and so on. Therefore, when developing hardware try to aim for 100% reliability before you start programming!


=== levels/Opcodes ===

$19693461238792* Set the counter increment to 4
$38976231780455* Watched state {nr} should point to a register or custom component with a register inside
$20916717363300* Watched state {nr} should point to the output
$18189600217529* Implement the OPCODE instructions
$13450117997204* Add a counter to the circuit
$77044880242883* Watched state {nr} should point to the counter
$13870568875751* Create a new schematic and add a program with 4 byte output
$10303603301757*
Implement the following opcodes:
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

The opcode NOT ignores the second argument.
$17495651785164* Add 6 registers to the map


=== levels/Nor GATE ===

$11362258372706
Большинство существ на этой вашей Земле агрессивны и не могут вести себя разумно.

Чтобы добиться успеха, вы должны научиться мыслить логически, без эмоций.



=== components/Mem Unit ===

$57670626909848* 1 bit of memory
$78616473760551* 1 Bit memory


=== ui/state_ui/title_screen/play ===

$66967233942803 Кампания


=== ui/options/Controls ===

$53266310714298 Управление


=== misc/run ===

$67345621265845* Run ticks (Hotkey: F6)


=== levels/byte_not ===

$14196498898485* Tool making and usage is key in the early evolutionary stages of developing intelligence.
$12982025748137* "NOT" each bit of the byte input.
$10294533225655* Our previous model of brain size being the main predictor of intelligence was naive.
$14958585065722* Therefore the number of arms on a creature is clearly the main predictor of intelligence. Did you know there are sea creatures from your planet with four times as many arms as you and they are doing better in tests?


=== components/Or64 ===

$50631450923181* Bitwise OR two values
$62930122175674* 64 Bit OR


=== components/Maker64 ===

$17464069717985* 64bit Maker
$79677187590355* Turns 64 bits into 8 bytes


=== misc/watchable_state ===

$58678516111149* Edit watched state


=== components/Xnor64 ===

$64937916903935* Bitwise XNOR two values
$47129074382309* 64 Bit XNOR


=== levels/wide_instrucitons ===

$13709034294291* Save on even tick, output both bytes on odd ticks
$17693995237077* Output both bytes
$19068760748550* Output 0 on even ticks
$65009239162932* The correct outputs were {a} and {b}
$19203973423116* Create a device that saves the program output on even ticks, and outputs both bytes on odd ticks.
$17409169138995* Save the byte


=== components/Nor32 ===

$82743668258816* Bitwise NOR two values
$82121937858245* 32 Bit NOR


=== levels/bit_switch ===

$56295261249455*
If components output different values on the same wire, you get an error. However, some components have grey output pins, these are not outputting at all when the component is not enabled. This is the case for the Bit Switch component.

[img]dialogue/bit_switch.png[/img]

This means that more than 1 of these grey output pins can connect to the same wire and not cause an error, as long as only one of them is enabled at a time.
$42793594302151* Using 2 NOT gates and 2 Switches, build an XOR gate.


=== misc/lab_toggle ===

$16432178820878* Lab


=== levels/Calculations ===

$14458828731919*
Time to merge in the "Arithmetic Engine" circuit you made previously with the register circuit. The calculation circuit was saved in the component factory and can now be added as a component. If you forgot which pin does what, check the circuit in the component factory.

Use the decoder you built to figure out if we should copy between registers or do calculations. Here are the 4 different modes again:
[OFF][OFF] Immediate
[OFF][ON] Calculate
[ON][OFF] Copy
[ON][ON] Condition

For this level you only have to worry about the copy and calculate mode, check [INSTRUCTIONS] in the top panel for the details. When in calculate mode, take [color=#e49f44]REG 1[/color] and [color=#e49f44]REG 2[/color] as inputs, and save the result in [color=#e49f44]REG 3[/color].

[tip]Don't forget the 3 bit decoder component has a disable bit.[/tip]
$13013863429580* For this level an extra pin has been added to the registers. This pin always emits the value of the register, regardless if load is selected or not.


=== components/Not64 ===

$74829633052959* Bitwise negates 64 bits
$81823773658328* 64 Bit NOT


=== components/Stack ===

$71022099146246* Memory that can be pushed or popped onto
$47202418972371* Stack


=== components/Program4 ===

$27522667367787* Program
$45650720555565* Programmable memory component


=== levels/Counter ===

$17701404772563* Add 1
$17940006660359* Count
$17263901743088*
Build a counter that will increase by 1 each tick.

Additionally, there should be an option for overwriting the counter with a given value.

You are given 2 inputs, a bit and a byte.

The bit input should toggle between counting and overwriting with the value of the byte.
$68874699768861* Overwrite with {value}
$10555159894041*
Counting is so fundamental even insects do it. From counting, species can evolve to compare and do arithmetic. And before you know it, you have apes building computers.

Make a device that counts increments once per tick.


=== components/Constant32 ===

$39402227599142* Constant value
$30896164786171* 32 Bit Constant


=== misc/sandbox_toggle ===

$30516879701896 Песочница


=== components/Xor16 ===

$55408021160573* Bitwise XOR two values
$47846591761838* 16 bits XOR


=== components/Rol64 ===

$49017662473189* Rotates the bits of an input left
$13677051385046* Rotate left


=== components/And32 ===

$98890160152994* Bitwise AND two values
$30264879217145* 32 bit AND


=== levels/byte_shift ===

$16023356915123*
The task in this level is to shift the first input to the left by the value given in the second input. The second input will never exceed 7.

$37338672894296* Shift the bits of {value} left by {amount}
$10598344098990* [center]Shift the first input left by the number of places given by the second[/center]
$16216408139965*
To [color=#e49f44]shift[/color] a value 1 left just means moving all the bits in a byte to the left by 1 position.
For example: [color=#e49f44]90 shl 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Shifting by 3: [color=#e49f44]90 shl 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]


$18137790657923* In addition to giving you a shift left component, we also had the intern create a shift right component. All he had to do was to create the mirror version of this schematic.
$18518173140953* I recommend that you add [color=#e49f44]shift left[/color] and [color=#e49f44]shift right[/color] to your hardware for future levels.


=== components/AND ===

$22719674432950*
[ON] when both inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]
$58912167455465* AND


=== main_menu/sandbox_button ===

$16857608955464 Песочница


=== levels/xnor ===

$11090938799865 Создайте "инвертированый" XOR gate, назовём его XNOR.


=== levels/decoder ===

$16133643476631* The circuit you built in the "Registers" level can copy values between registers, while the "Arithmetic Engine" can do different operations on 2 inputs. But you need to be able to do both in the same circuit. To do this, build a "decoder", which will decide which mode our computer is in, based on the 2 bits we haven't used yet.
$18435544383511* CALCULATE pattern\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18945946395447*
To distinguish between the [INSTRUCTIONS] of 4 different kinds, the two highest bits will be used to determine which MODE we are in as follows:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Immediate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculate
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copy
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition

Here [ANY] means any value.

Determine the MODE we are in from the input, then send [ON] to the correct output.
$15105859227432* COPY pattern\n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12671132029272* Your circuit has been saved to the component factory.
$12068329066372* [b]ALERT: THIS IS AN OUTDATED VERSION OF THIS MAP, PLEASE CLICK THE SAVE ICON IN THE TOP LEFT AND CREATE AND LOAD A NEW SCHEMATIC[/b]
$11382827588408* CONDITION pattern\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611* IMMEDIATE pattern\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542* IMMEDIATE


=== levels/bit_inverter ===

$15769391111364* When "Invert" is [ON], output the opposite of "Value". Otherwise, just output "Value" as is.
$15272914096446* This level is exactly the same as the XOR one you solved before. Remember no matter what we tell you the goal of the level is, the real truth is in the truth table.
$14944872827527* Despite the funny background you figured out this was just the XOR gate in disguise! Well done.
$16125025706490* Hmm, perhaps you have studied memory a little bit too well...
$13224963076378* We are experimenting with how backgrounds influence cognitive functions in earthlings.


=== levels/ram_block ===

$12901484249817* Can you fit 4 bytes of memory in this limited space?
$14218335256117*
In our advanced civilization, forcing prisoners to do extremely menial tasks is slavery and is technically illegal.
	  That is why we instead had our intern create the 256 byte version of your component.
$15908016538045* VALUE
$16196915566111* 0
$14259545926196* A
$12306130287676*
In this level you have to build a circuit that 
can [SAVE] or [LOAD] from 4 different bytes of memory.

You are given 1 bit that determines if you are to [LOAD]. Another bit determines if you are to [SAVE] and it comes with a corresponding value.
Additionally, you have 2 address bits. 

With 2 bits, there are 4 combinations, one for each byte of memory in this level.
[i][tip]Join wires in the middle and use right angles or this will be a mess.[/tip][/i]
[i][tip]Spacebar rotates components.[/tip][/i]

The output has an enable pin, enable it only on [LOAD].
$18084166025569* Nothing
$13082830776248* DON'T LOAD
$12933801309767* A


=== components/Shr64 ===

$93124177265670* Shifts the bits of an input right
$73798355428095* Shift right


=== components/Constant64 ===

$92424468899005* Constant value
$25858905835416* 64 Bit Constant


=== component_panels/LatencyRam ===

$87788654491792*
This kind of RAM would add 1024 delay to the circuit, but instead of extending the duration of ticks, we simply don't wait for the output.

Practically this means that [color=#e49f44]reading takes {ticks} ticks[/color] (since your circuit has {delay} delay).


=== main_scripts/overture_level ===

$27259865408750* Next tick the counter value will be {next}, it should be {expected}
$95030012922256* Input should only be enabled when reading from input
$12873109232054* Expected output {expected}, got {got}
$47188699762650* Output not enabled
$28026304798371* Output should only be enabled when outputting
$85260864781281* Input not enabled
$96569633331621* Load {value} into REG 0
$83829200305236* Expected output {expected}, got {got}


=== levels/Further Delayed Lines ===

$17366913897135 Создайте цепь которая выводит свой собственный вход с задержкой в 2 такта.
$60989431641221*
This level introduces the Delay Line component. It takes its input and outputs it 1 tick later.

[img]dialogue/delay_buffer.png[/img]


=== levels/negative_numbers ===

$12574817679356*
We need a way to have negative values in bytes. The scheme we have been using so far can represent all numbers from 0 to 255 using a byte. This scheme is called "unsigned", since it only deals with positive numbers.

We need a scheme that allows negative numbers, normally referred to as a "signed" representation. 

Additionally, it would greatly simplify future circuits if the representation works with the adder you already made. 
$17231048881956 Для оценки различий в вещах и величинах, Вам потребуется ВЫЧИТАНИЕ. А, для процесса вычитания Вам, строго говоря, необходимы отрицательные числа. 
$70755151984986* {a} should be {b}
$11067230116844* {number} is not representable
$62744038163781* OK
$19118970740682*
[color=#dd6576]Edit the numbers[/color] for each bit so that the following is true:

[color=#e49f44]1[/color]: All numbers from -127 to 127 should also be representable
[color=#e49f44]2[/color]: Bytes representing anything from 0 to 127 should be the same as unsigned
[color=#e49f44]3[/color]: The new number system should work with the adder (for results between -127 and 127).
$15431436023571* You have two ways to represent 0\nWhich leads to 0 + 1 = 0
$28284583096369* 1 plus -1 does not equal 0\n  
$57604042654667* {number} is not representable


=== levels/robot_race ===

$15403032472607* Robot racing is the favorite sport on the spaceship. Differently programmed robots complete an obstacle course. Among the robots that complete the course, the winner is the one who had the smallest program.
$19966247197959* This time you are controlling Fastbot, he doesn't see what is in front of him, but he can turn to a new direction and move in the same tick. Also he wears fancy red running shoes.


=== levels/NAND Gate ===

$17420270098223 На этом уровне вам предстоит разобраться как работает компонент NAND. [color=#dd6576]Обязательно[/color] разберитесь в этом прежде чем завершать уровень, иначе рискуете "застрять" на следующих уровнях!
$11034378482152 Верно! Вы разблокировали NAND элемент. С помощью этого компонента можно создать всё что необходимо для вашего компьютера!
$18270083417453 Проверка
$19208664264770 [b]Инструкция:[/b]\nНажмите любую серую кнопку в последней строке таблицы внизу.
$17923274216766 Что ж, придётся признать, что Ваш вид развит несколько лучше простейших микроорганизмов.
$14777350869870 Мы удивлены насколько успешно вы справились с предыдущей проверкой!
$17994568832660 [b]Инструкция:[/b]\nКомпонент NAND переключает потоки в электрической цепи.\nИспользуйте переключатели слева для экспериментов с Вводами(Inputs).\nПонаблюдайте как это влияет на потоки и Вывод(Output),\nа затем заполните последюю строку в таблице внизу.

=== components/Input 2 ===

$86870364449392* Input


=== components/OutputCounter ===

$52247325526438* Counter


=== components/DelayLine8 ===

$24840584785792* Outputs this tick's input, next tick
$63449911993783* 8 Bit Delay Line


=== components/Xnor16 ===

$73699169812942* Bitwise XNOR two values
$40088995721509* 16 Bit XNOR


=== components/Bit Compressor ===

$74338505460996* Turns 8 bits into 1 byte
$98747779812970* 8 bit Maker


=== components/Off ===

$61860786587357* OFF
$72749460799924* Always [OFF]


=== components/Shr16 ===

$20291717268875* Shifts the bits of an input right
$31674686871821* Shift right


=== components/Bidirectional8 ===

$20234315861487* 8 bit bidirectional pin
$49499540884410* Can circumvent certain circular dependency errors


=== components/Screen ===

$12771040946773* Displays the visuals that accompany certain levels
$50037736094411* Screen


=== misc/ide_control_link ===

$80788685813993* Robot controls


=== levels/Calibrating Laser Cannons ===

$11331851878040* Also you now have access to assembly programming. It allows you to add names for instructions, so you can for example type "add" instead of inputting 68.
$11023157447564*
2×π×r

r is the input.
And you can approximate π as 3.

Send the answer to output when it has been calculated.
$15260627694444* In order to calibrate said laser, we want you to calculate the circumference of the asteroids using an advanced equation.
$12669851602178* [center]Calculate the circumference of the asteroids[/center]
$21601709632806* What is 2π × {radius}?
$16954408093587* On our ship we naturally shoot incoming asteroids with lasers.


=== components/Mux64 ===

$14050204031082* Toggles between two values
$66892629981737* 64 Bit Mux


=== levels/circular_dependency ===

$16336401898647 ТЕСТ 1 из 2
$13880985462901 Создайте цепь, в которой Ввод компонента зависит от его собственного Вывода
$18010308863615
Создайте «круговую зависимость». Это схема, в которой вход компонента зависит от его собственного выхода. В ситуации круговой зависимости невозможно определить выход компонента, потому что сначала нужно определить вход, который зависит от выхода и т. д. (потому и называется «круговой»).

Эта ситуация обычно не разрешается в остальных уровнях, но в этом уровне цель состоит в том чтобы его создать, чтобы вы поняли что это такое прежде чем двигаться далее.
$13520037133129 Не уверен, что это приносит пользу ученикам, но учителя в полном восторге!
$11316928751185 Наша система образования, по давней традиции, подразумевает обман учеников, мы часто просим их делать то чего делать вообще нельзя и наблюдаем за эффектом. 


=== misc/ui_panel/left_inputs ===

$16586225094516* INPUTS


=== components/Xnor32 ===

$17419057954798* Bitwise XNOR two values
$52489451755306* 32 Bit XNOR


=== components/NOR ===

$27510848535619*
[ON] when neither inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell]
[/table]
$83375115196253* NOR


=== levels/hex_racer ===

$92057009138253* What is {number} in binary?
$16009852370452*
When dealing with a lot of bits, binary can become hard to read. Hexadecimal (base 16) represents each combination of 4 bits as its own character:
[code]
0 [OFF][OFF][OFF][OFF]
1 [OFF][OFF][OFF][ON]
2 [OFF][OFF][ON][OFF]
3 [OFF][OFF][ON][ON]
4 [OFF][ON][OFF][OFF]
5 [OFF][ON][OFF][ON]
6 [OFF][ON][ON][OFF]
7 [OFF][ON][ON][ON]
8 [ON][OFF][OFF][OFF]
9 [ON][OFF][OFF][ON]
A [ON][OFF][ON][OFF]
B [ON][OFF][ON][ON]
C [ON][ON][OFF][OFF]
D [ON][ON][OFF][ON]
E [ON][ON][ON][OFF]
F [ON][ON][ON][ON]
[/code]

As an example where hexadecimal is much clearer, lets compare the representation of the largest 16 bit number:
[code]
Binary:      1111111111111111
Decimal:     65535
Hexadecimal: FFFF
[/code]

It is not easy to tell if the binary is missing a digit or if the decimal number is off by 1, the hexadecimal on the other hand is immediately clear (once you get used to the representation at least).
$84691609525475* This level is my second favorite pastime. Converting hexadecimal to binary under time pressure.
$45532697833519* You made it to level {level}!
$87016829502381* Good job, you reached level {current_level}.
$43463538043782*
Toggle the bits in the level panel so they add up to the hexadecimal number in the question.

You must beat level 3 to pass.

(click [color=#e63e5b][url=accessibility_mode]here[/url][/color] to turn on timerless accessibility mode)


=== components/Or3 ===

$17576327690867* 3 pin OR gate
$99630419947500* 3 Pin OR


=== components/Ror8 ===

$10802217509530* Rotates the bits of an input right
$70999134800536* Rotate right


=== levels/Water World ===

$13739681561355* Total volume: 
$19185457941725* Good news, we want to turn earth into an exotic water park!
$18940654086036* We need you to help us find a good location for the Pirate's Plunge waterslide. Specifically, we are looking for an area that can hold a high volume of water.
$14706805272652* Hit ENTER to show water
$12881972193444*
The landscape is 16 columns wide. Read the input 16 times to get the height of the landscape at each column from left to right.
	
Then output the total volume that the landscape can carry as the answer.


=== components/NAND ===

$71130919681688* NAND
$12903183841172*
[ON] unless both inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== components/Output1Sum ===

$90026011029075* Sum


=== ui/top_bar/scores ===

$56840961921536* GATE SCORE: \nDELAY SCORE:


=== levels/Dancing Machine ===

$14975070588197*
We all like the way Robot moves on the dance floor. That's why we want him to lead our dance team. 
	
The only problem is to make him come up with original dance sequences. How do you make creativity out of deterministic logic you ask?

The answer pseudo random number generators.
$15955150920362*
In this level you only get one input, we call this the initial seed. The seed is put through the following steps to produce a pseudo random number.

In the algorithm below, "shl 1" means shift left once, "shl 2" means shift left twice and "shr 1" means shift right once.

[b]8 bit xorshift RNG:[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
Next output next_seed mod 4, to move the robot. Finally use next_seed (before mod 4) as the seed to get the next number in the dance sequence and repeat.

(Notice the initial seed will never be 0)


=== components/Input 4 ===

$11447837612693* Input


=== components/Input64 ===

$31709565019284* 64 bit input


=== levels/Add 5 ===

$11540713506719*
You are now free to change the program of your computer.
Click the edit icon on the program component to start programming.
$19281970848639* [center]Add 5 to the input.[/center]
$17770257567603* So in the meantime we will have you help out on the ship a little.
$19446152707984* Click on the edit memory icon on the program component to start programming your computer. Your computer should read an input, add 5 to it and output it again (no need to worry about overflow).
$80639633676917* Input:
$12078933051174* But since you don't know how to program it yet, you are not quite ready for that.
$11074247151096* Notice that the immutable red register components have been replaced with a custom component with identical functionality.
$18134632592542* You have built your computer, but to win the competition you still have to finish the maze.


=== components/Output16z ===

$78873885833823* 16 bit switched Output
$54278394672948* Only outputs if the switch pin is [ON]


=== main_scripts/levels ===

$64510812504271*
Some of the components used are not supposed to be available in this level!
The solution is not scored.


=== misc/credits ===

$15234594767991 Титры


=== misc/program_edit_signals ===

$98772447663910* Edit watched state


=== components/ByteMul ===

$56549841656852* Multiply
$68631919890554* Multiplies two inputs


=== component_panels/Counter ===

$57936010210151* Increment by: {amount}


=== levels/1_decoder ===

$16057674753878 Создайте компонент, который сможет переключать "поток" между двумя контактами.


=== levels/byte_mux ===

$49305362057225* Your answer {your_answer}\nCorrect answer {correct_answer} (Input {input})
$18296416014178* When the bit selector input is [OFF], output Byte A, otherwise output Byte B.
$17093993196554*
Even though he did not pass our tests we decided to keep the dog. Unlike most earthlings he is fluffy and follows simple instructions well. 

We might want to team you two up, since you compliment each other's shortcomings well.


=== misc/component_factory_toggle ===

$55499239951858* Component Factory


=== components/Output8z ===

$16915419621070* 8 bit switched Output
$58449766432492* Only outputs if the switch pin is [ON]


=== components/ByteConstant ===

$29445030761909* Constant value
$25159790815891* 8 Bit Constant


=== components/Counter32 ===

$87245349851451* 32 Bit Counter
$92765669828982* Increments each tick, unless overwritten


=== components/Output64 ===

$43552728118031* 64 bit output


=== components/Add32 ===

$91616185859914* Adds two inputs
$64111401384153* Add


=== components/NEG ===

$88379907297327* Negate
$62021716182809* Bitwise negates an input


=== components/Switch16 ===

$15221175893882* 16 Bit Switch
$59845475842015* Toggles a value


=== components/Or32 ===

$92752025948920* Bitwise OR two values
$40180779432911* 32 Bit OR


=== components/And3 ===

$19664974941910* 3 Pin AND
$86839706221116* 3 pin AND gate


=== components/Maker16 ===

$55864807379312* Turns 16 bits into 2 bytes
$39941195789458* 16 bit Maker


=== components/LessU32 ===

$72614358420262* Less (unsigned)
$55380524073095* Checks if one input is less than the other


=== levels/sandbox ===

$17054292175058* Welcome to the sandbox, here you are free to play around. I have given you 64 bit wires and a few IO components.
$10731996208080* There are also 64 bit versions of the program, the counter, the register and the ram. Notice though, the 64 bit ram takes 1 tick to load.
$72764802067974
Добро пожаловать в песочницу. 

Components are available in the menus on the right side. Once placed, click on the pins of the components and drag to connect them with wire. On the left you will find the UI for the simulation control. Note that you can right click on the "Run faster" button to set target speed.

You can find more information about the simulation in the manual (button is in the top left). Notable features to check out are the "component factory" where you can create your own components and the program component, which lets you define your own assembly.
$19454393978813* The keyboard lets you directly control your computer, using your ... keyboard
$14434122873489* The Waveform Generator lets you make sounds. I will probably regret giving you this one.
$18405942066048* The Clock gives you the current UNIX time in microseconds.
$10451578314373* The Console Screen lets you draw characters to a screen (see manual for ascii characters)


=== components/Output64z ===

$61656790122480* 64 bit switched Output
$42506906257154* Only outputs if the switch pin is [ON]


=== components/NOT ===

$34453052824732* NOT
$90844421681709*
Inverts the input
[table=3]
[cell]Input[/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== levels/Crude Awakening ===

$12508086025944
Мы устроим Вам проверку.

Правила просты, постройте действующий компьютер или мы вас сожрём. Удачи!
$16321577947087 Поздравляем, вы были похищены!
$19257730429557 Электрический сигнал "течёт" от компонента IN(Вход) к компоненту OUT(Выход).
$17675121574388 Обратите внимание, что компонент OUT выключился.\nЭто потому, что сигнал от компонента IN прекратил своё "течение".


=== ui/toggles/race_condition ===

$75558678297830* Circular dependency


=== levels/byte_or ===

$10368115829346* But actually it is OK because you lived good lives in the wild and we don't let the meat go to waste.
$15923734370936*
OR each bit of the input bytes and output the result.

For example:
[code]
INPUT 1 [ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
INPUT 2 [OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
OUTPUT  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]

$15226896485081* You may think it is unethical to eat all the earthlings that don’t win the competition?


=== misc/wire_draw ===

$59836059268386* New wire (Hotkey: Alt & drag)


=== components/And16 ===

$56198785587874* Bitwise AND two values
$26727645933234* 16 bit AND


=== misc/program_edit_button ===

$38481453712356* Edit memory


=== levels/Conditionals ===

$10794262854382*
Add if statements to your circuit. For the if statements, the 2 arguments are compared and if the condition is true, the counter is set to a jump address.
	
The previous instructions had the 4 bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, RESULT[/color][/code]

For if statements the bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, JUMP_ADDRESS[/color][/code]

In addition to the previous opcodes, add:
[code][color=#87a8c8]32 IF_EQUAL
33 IF_NOT_EQUAL
34 IF_LESS
35 IF_LESS_OR_EQUAL
36 IF_GREATER
37 IF_GREATER_OR_EQUAL[/color][/code]

Use unsigned less / greater for the comparisons.

Each opcode does what their name implies. For example the following jumps to byte 16 if REG0 is less than REG1: 
[code][color=#87a8c8]IF_LESS REG0 REG1 16[/color][/code]

$18542005958715* Set the counter increment to 4
$17133561664335* Congratulations, you finished the [color=#e49f44]LEG[/color] computer!
$14973719570693* Add a counter to the circuit
$12920514303805* Add 6 registers to the map
$14309211963063* Create a new schematic and add a program with 4 byte output
$16826220977157*
 [color=#b72d41][b]TIP:[/b][/color] 
 COPY is just ADD with the second
 argument being 0
$14690660047411* Implement the condition opcodes
$30132649789584* Watched state {number} should point to the output
$18994998239232* I will show you some upgrades you can make, on the path to implementing function calls. But from here on the details are up to you, I wont tell you what opcodes to use and so on.
$12034111753799* Watched state {number} should point to the counter
$36561706158040* Watched state {nr} should point to a register or custom component with a register inside


=== misc/instr_clone ===

$69090690657232* Clone


=== levels/byte_less ===

$11252365204151* Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]UNSIGNED[/color].
$62766453128684* Is {a} less than {b}?
$11632471752785* [center]Determine if the first input is less than the second.[/center]


=== levels/Logic Engine ===

$15865646260225*
 [color=#b72d41][b]WISDOM:[/b][/color] 
 Pain is temporary, glory is 
 forever.
$17594613477534*
Create a device that can OR, NAND, NOR or AND two inputs. The third input will be the [INSTRUCTION]. An [INSTRUCTION] is just what we call the number that determines what to compute.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

Also you can't move the red components in this level, for reasons that will be revealed later.


=== levels/always_on ===

$17712385236630 Создайте цепь на выходе которой всегда [ON].


=== components/And64 ===

$80790829001391* 64 bit AND
$89424947351456* Bitwise AND two values


=== misc/inst_new_rule ===

$41064305626707* New rule


=== misc/multi_select ===

$85147529532131* Multi select (Hotkey: SHIFT & drag)


=== misc/reset ===

$39440928972984* Reset (Hotkey: F4)


=== components/ByteEqual ===

$39369982838671* Equal
$35668435514829* Checks if the two inputs are equal


=== levels/binary_racer ===

$16076448195257 Это испытание, в последнее время, стало моим любимым. Конвертация десятичных чисел в двоичные на скорость.
$37319690622142* Good job, you reached level {current_level}.
$19111664765554
Переключайте биты (степени числа "два") внизу, чтобы составить десятичное число.

Пройдите хотя бы 3 уровня!

(Нажмите [color=#e63e5b][url=accessibility_mode]здесь[/url][/color] чтобы играть без таймера.
$11176073682097* What is {number} in binary?
$71866932309393* You made it to level {level}!


=== components/Mul64 ===

$72281597169494* Multiply
$11665562499390* Multiplies two inputs


=== levels/xor_gate ===

$14093358515620 Эту штуку ещё называют XOR gate. Это довольно сложный уровень, не пугайтесь если не найдёте ответ сразу.
$19182751521677 В прошлый раз мы строили цепь, которая выводила [ON] на втором такте. А сейчас Вам предстоит построить цепь, которая будет выдавать [ON] на втором и третьем такте.


=== components/Splitter64 ===

$80420054807186* Splits 64 bits into 8 byts
$14205692632393* 64bit Splitter


=== components/Bidirectional64 ===

$82412839066570* 64 bit bidirectional pin
$24932613021646* Can circumvent certain circular dependency errors


=== components/Splitter16 ===

$92674917729864* 16 bit Splitter
$28271182652741* Splits 16 bits into 2 byts


=== misc/component_button ===

$75542474510177* GATE
$63839315669055* DELAY


=== components/SRLatch ===

$11641785582600* Set/Reset Latch
$71931050184389* [img=165]dialogue/sr_latch_tooltip.png[/img]


=== levels/bit_adder ===

$13109388951000 Для познания окружающего мира мы, как правило, используем числа. Неплохо бы научить ваш потенциальный компьютер считать.
$16564356062672
Давайте попробуем воспринимать [OFF] и [ON] как [ZERO] и [ONE], соответственно. Вычислите сумму Вводов(INPUTS) в двоичном формате, результат(SUM) будет [ZERO] или [ONE].

Как и в обычном сложении, если результат не помещается в один разряд, установите перенос разряда(CAR) в значение [ONE].


=== components/Maker32 ===

$82420653444614* Turns 32 bits into 4 bytes
$85308499118176* 32 bit Maker


=== components/Output 3 ===

$96269858195218* Output


=== main_scripts/dialouge ===


NOTE: hint for odd number
$68750974209145* You can figure out if 2 inputs have an odd number of [ON] with just 1 component...

NOTE: hint for the bus
$50799425816171* Use switches to put the inputs on the same wire.

NOTE: Hitn for byte switch
$86319296925137* What would this look like if you were only switching 1 bit? What would the truth table for such a component look like?

NOTE: Hint for byte adder
$37093555217568* You only need 8 full adders.

NOTE: Hint for the maze
$36837749971886*
Always following the left (or right) hand side of the maze will make sure you eventually reach the exit.
	
The pseudo code for such an algorithm looks like this:
 Step forward
 Turn left
 Turn right as long as there is a wall ahead
 Press use after each turn (in case the exit is ahead)
 Repeat

NOTE: hint for counting signals
$21044442262778* The circuitry for the 1's bit is the same as what you did in the level "Odd Number of Signals". The circuitry for the 2's bit is what you did in "Double Trouble", except when all 4 are on.

NOTE: hint for saving gracefully
$25321701584378*
In this level you need to use 1 Delay Line. Make a truth table for what should go into the Delay Line. Consider the input to the Delay Line as the output for your table. 

The inputs are the 2 level inputs AND the output of the Delay Line, as the output plays a role in its input. In total you have 3 "inputs" to for this table which gives you 8 combinations. Once you have the level requirements as a table, it should be a lot easier to solve.

NOTE: Hint for conditions
$87674181578455*
There are 3 condition bits. The first bit being [ON] means the result being 0 meets the condition. The second bit being [ON] means the result being less than 0 meets the condition. If either of those two are [ON], the condition is met. 
Finally, if the last bit is [ON], negate the status of the condition being met or not.

NOTE: hint for xor gate
$88963098241493* This level can be done with 3 components, a NAND, an AND and an OR gate.

NOTE: Hint for masking time
$46866534894828*
In binary, taking modulo 4 of a number is the same as only using the two lower bits. This is because the higher bits represet 4, 8, 16 etc, and they all divide 4 with no remainder.
This is true in general for modulo a power of 2, the lowest bit of a number represents that number modulo 2 (even or odd), the lowest 3 bits modulo 8 and so on.

Likewise, in decimal 4321 modulo 100 is also simple (answer is 21, the higher digits are disregarded), this is because 100 is a power of 10.

Now you just have to figure out how to get the last 2 digits of a number.

NOTE: hint for less
$56438995128380*
First determine which bits are different between the 2 bytes. This can be done using a byte XOR (remember XOR turns [ON] when the inputs are not the same). We know the number that has the highest different bit [ON] is the larger number. But we must only consider the highest different bit, so for each bit, use a chain of OR gates to check if any higher are [ON].
		
Finally, the last bit is considered seperately for signed numbers, here it has the opposite effect (if only one number has it [ON], that number is guaranteed to be lower)


=== components/Output 1B ===

$77044600156969* 8 bit output


=== components/Xor64 ===

$95012060885697* 64 bit XOR
$13031452187028* Bitwise XOR two values


=== components/ByteXor ===

$98219910712564* 8 bit XOR
$83236921580268* Bitwise XOR two values


=== components/Hdd ===

$75645507178296* HDD
$78558655732992* Persistent memory


=== components/LessI32 ===

$87609006355839* Less (signed)
$99994775592318* Checks if one input is less than the other


=== levels/Spacial Invasion ===

$19967210826470* Be aware that the laser can only shoot when there are no other laser beams already in flight.
$16294185981398* The cargo hull has become infested with space rats.
$11505369795084* Check [color=#e49f44][url=the_robot]robot page[/url][/color] for instructions on how to program him. There is a link to that page in the program editor as well.
$10515630949378* We have hooked your machine up to our advanced robot and we want you to program it to shoot the space rats with lasers.


=== levels/double_number ===

$74261206899285* Your result {input} × 2 = {your_answer}\nCorrect result {input} × 2 = {correct_answer}
$19766257822639
Ввод и Вывод на этом уровне используют БАЙТы вместо БИТов. Один из двух новых компонентов умеет "разбирать" БАЙТ на БИТы, а второй наоборот "собирает" БИТы в БАЙТ.

Используя эти компоненты придумайте как удвоить число на Входе (число на входе не больше 127).


=== levels/counting_signals ===

$10724914203078
Вывод на этом уровне это двоичный счетчик, у которого каждый из трёх контактов соответствует числам "1, 2 и 4" соответственно.
Используйте его для подсчета входов в состоянии [ON].\nЗатруднения?

[color=#e63e5b][url=counting_signals]подсказка здесь[/url][/color] если застрянете.

[i][tip]Решение этого уровня не очень красивое и может потребовать больше компонентов.[/tip][/i]

$10881918807029
 [color=#b72d41][b]Совет:[/b][/color]
 Использование карандаша и бумаги
 не является чем-то постыдным.




=== components/Nand8 ===

$50859914201083* Bitwise NAND two values
$93314093190526* 8 Bit NAND


=== components/Add64 ===

$14174811828377* Adds two inputs
$73418471595285* Add


=== ui/toggles/level_map ===

$71951682957395* Level map


=== ui/state_ui/title_screen/exit ===

$12639868461113 Выйти


=== misc/button_next ===

$50213503063080* Next tick (Hotkey: F5)


=== misc/ui_panel/memory ===

$65362728703588* MEMORY


=== levels/saving_bytes ===

$10633476398156*
Create a circuit that can [SAVE] or [LOAD] a byte.

When the first input bit is [ON], [LOAD] the memory and send it to output.
When the second input bit is [ON], [SAVE] the input byte.

The output has an enable pin, enable it only on [LOAD].

$13502950630653*
[color=#ff9800]None
0
0[/color]
$19109563882664* DON'T LOAD
$16372198430230* SAVE
$15498440508450* Do nothing
$18873598212433* LOAD
$15582618410991* LOAD and SAVE


=== misc/level_gate_component_icon ===

$83440578602427* Unlocks component


=== levels/any_doubles ===

$16587030847545 Поскольку мы очень продвинутая раса, мы давно изобрели машину для сортировки носков. К сожалению, в машине сломалась схема, которая определяет пары носков.
$14373083988184 
На этом уровне 4 входа.
Установите выход в [ON] когда 2 или больше входов установлены в [ON].

[tip]Не "перемудрите" на этом уровне.[/tip]


=== levels/byte_constant ===

$12641789008694* Create a circuit that always outputs the number 164.


=== components/Output 1 + 1B ===

$43917122084061* Accepts output for levels
$81929942356043* Level output


=== levels/call_ret ===

$15840165316981*
In this level you are tasked with implementing function calls and returns with the [color=#e49f44]call[/color] and [color=#e49f44]ret[/color] instructions.

Note that when returning from a function, you should jump to the address that came AFTER the [color=#e49f44]call[/color] instruction, otherwise you will end with an infinite loop.
The [color=#e49f44]call[/color] instruction has to do the following:
 [i]- Add the instruction width to the counter value and [color=#e49f44]push[/color] it on the stack[/i]
 [i]- Jump to the function address[/i]

The [color=#e49f44]ret[/color] instruction has to do the following:
 [i]- [color=#e49f44]Pop[/color] return address from the stack and jump to it[/i]

You can pass information to and from a function by saving the data to registers as normal. Also be aware of which registers a function will overwrite before calling it.

$19416009887091*
Sometimes it is useful to reuse a section of code. We call these sections "functions". To implement this reuse, one can [color=#e63e5b][url=termonology]jump[/url][/color] to the beginning of the function and jump back again at the end of the function. We call jumping to the function "calling" the function, and jumping back from the function "returning" from the function. 
	
But for this section of code to actually be reusable, the return jump will have to be able to return to different locations, depending on where we called the function from.

We could save the counter value to a register before jumping to the function and use this value when returning. However, if done this way, a function would not be able to call another function, since this would overwrite the original return address.

Say function A calls function B, who calls function C. When we want to return from C, we only need the return address for B and in B we only need the address for A. In general, regardless of which function we look at and how they are nested, the last return address we added is always the first one we will need again. This is exactly the behavior of the stack.
$19369640789869* Budget cuts have led to cutting salaries, but now the lab assistants are on strike. You will have to self-assess in this test. This will tell us something about your honesty and maturity.
$15463931654475* [center]Add "call" and "ret" instructions[/center]


=== levels/odd_ticks ===

$18510295620397 Выведите [OFF] для четных тактов и [ON] для нечетных тактов.
$16987046679863 На предыдущем уровне вы узнали, что мы не допускаем круговых зависимостей. Теперь вы должны выучить одно исключение.
$16037516781370
Квадратные контакты в игре никогда не влияют на вывод в тот же такт. Поэтому они никогда не вызывают круговых зависимостей.
	
	[img]dialogue/delay_buffer.png[/img]
$17588119878416
Линия задержки может зависеть от собственного входа. Это потому, что её вход не влияет на остальную схему до следующего такта. 
	
[img]dialogue/delay_buffer.png[/img]


=== components/DelayLine1 ===

$30487770736917* Delay Line
$38206009264853* Outputs this tick's input, next tick


=== components/Adder Simple ===

$33973952772642* Add
$98429814030509* Adds two inputs


=== components/DelayLine32 ===

$56616725618490* Outputs this tick's input, next tick
$49292282287971* 32 Bit Delay Line


=== components/Nand64 ===

$27197172037913* 64 Bit NAND
$66590147372797* Bitwise NAND two values


=== components/DelayLine16 ===

$61925612221077* 16 Bit Delay Line
$65706144678496* Outputs this tick's input, next tick


=== components/ByteShr ===

$89595863403484* Shift right
$69394421220436* Shifts the bits of an input right


=== components/Neg64 ===

$88458190974122* Negate
$52206550732945* Bitwise negates an input


=== main_scripts/leg_level ===

$70383685548547* REG {nr}
$53021804895845* ANDi
$69956969985790* ORi
$85913831661289* IF_LESS
$11144256835662* XORi
$61412773713567* SUB
$20104629254326* ARGUMENT 2
$52344899983501* IF_LESS_OR_EQUAL
$89945092889418* SUBi
$89011349770597* NOT
$71559031724238* IF_NOT_EQUAL
$40520283279584* XOR
$71204580217527* NOTi
$71195301111400* ADDi
$98178474649432* IF_GREATER_OR_EQUAL
$68187490877029* IF_EQUAL
$38681417496680* ARGUMENT 1
$50722296752142* INPUT
$43723329256095* REG {nr}
$37810243909140* COUNTER
$44009845985661* ADD
$68666991962246* OR
$79492115258673* IF_GREATER
$60997201855346* RESULT ADDRESS
$64519909700148* AND
$49810487048038* COUNTER
$18236360532765* OUTPUT
$84307766381146* OPCODE


=== components/LessU64 ===

$13018528868948* Less (unsigned)
$90244529484227* Checks if one input is less than the other


=== ui/options/Robot Controls ===

$58799802152286 Управление Роботом


=== levels/divide ===

$16412715945615 [center]Разделите одно число на другое[/center]
$14525870461271
Целочисленно разделите два числа чтобы найти частное и остаток. Рассмотрим дробь 7/3. 3 умещается в 7 два(2) раза, при этом, 1 остается "в остатке". В этом случае 2 принятно называть [color=#e49f44]ЧАСТНОЕ[/color], а 1 [color=#e49f44]ОСТАТКОМ ОТ ДЕЛЕНИЯ[/color].\nВ этом задании вы получаете числитель (например 7) и знаменатель (пусть будет 3), и мы ожидаем увидеть ЧАСТНОЕ (2) и ОСТАТОК (1).
В этом упражнении, вам сначала даётся делимое (7 в примере) а затем делитель (3) и от вас ожидается вывести частное (2) а затем остаток (1).
$76454016047920* {numerator}/{denominator} = {quotient}, remainder {remainder}


=== components/Nor64 ===

$17208777467974* Bitwise NOR two values
$72509242083648* 64 Bit NOR


=== misc/solution_option ===

$21618236951146* View solution


=== misc/run_fast ===

$49363678936533* Run ticks faster (right click: change target speed)


=== misc/ProbeWireBit ===

$49521764791439* Wire Probe (bit)
$15206117280094* Display a value on your custom component or in the program editor


=== components/Output 4 ===

$90190739202646* Output


=== components/Rom ===

$24976506406652* ROM
$81743370431597* Read only memory (outside the sandbox)


=== misc/select_color ===

$97461374731210* Wire color


=== misc/instruction_expand ===

$44690074039467* Toggle define rules


=== components/LessU16 ===

$91783087669146* Checks if one input is less than the other
$33190791348214* Less (unsigned)


=== components/Xor32 ===

$66299093873977* 32 bit XOR
$38169019785615* Bitwise XOR two values


=== levels/Delicious Order ===

$10160261151833* First read the 15 deliciousness scores from the input one by one. Your task is to output them in sorted order, smallest to largest.
$16027225087666* We are updating the galactic encyclopedia of food, inserting human foods. As we don't have an alphabet, entries in the encyclopedia are ordered by deliciousness.


=== components/Equal64 ===

$34603983706314* Checks if the two inputs are equal
$82876546747608* Equal


=== components/Bidirectional16 ===

$31038378395810* 16 bit bidirectional pin
$99604485981015* Can circumvent certain circular dependency errors


=== components/Register ===

$19705753304166* 8 bit memory
$68946767861738* 8 Bit Register


=== levels/push_pop ===

$78804623186243* OUTPUT
$49526452710191* DON'T POP
$58050047963238* VALUE
$19245209470436* Create a stack
$12227209887733*
Each tick the inputs will either signal PUSH or POP. If it is PUSH, store the value on top of the stack. When it is POP remove that value from the stack and output it.
	
The output has an enable pin, enable it only on POP.

$15662660252584* Do nothing
$62469306234943* DON'T PUSH
$46948857059388* POP value {value} off stack
$18761197388580* In order to cut spending, it has been decided to change the queuing system at public offices so that fewer people will go. Instead of first come, first served, we are implementing a last come first served policy. Think of it like a [color=#e49f44]stack[/color] of numbered slips where the citizens either put a slip on top (called [color=#e49f44]PUSH[/color]), or the bureaucrats take one off the top of the stack (called [color=#e49f44]POP[/color]). We want you to implement this new system.
$65188797398656* PUSH {value} on stack


=== levels/Tower of Radioactive Alloy ===

$13757925963562* Specifically we want you to move piles of radioactive disks from an old reactor. Just be sure not to put a bigger disk on top of a smaller disk or the whole ship will blow up.
$10750976989948*
The first 4 inputs will give you the following in order:
disk_nr - The highest disk number in the pile (2 to 4)
source - Which location number to move from
destination - Where to move the pile to
spare - The 3rd spot that is neither the source nor the destination

Control the crane with the following outputs:
0 - Move the magnet to spot 0
1 - Move the magnet to spot 1
2 - Move the magnet to spot 2
5 - Toggle the magnet on or off

Play with the magnet manually by using the arrow keys to move and enter to toggle.
$19265994465686* We need you to help clean up the basement.
$35120623183961* Move from {source} to {destination}
$15855497886737*
Implement the following algorithm:

Tower of Hanoi algorithm:[code][color=#87a8c8]
func move(disk_nr, source, dest, spare):
	if disk_nr is 0:
		move disk from source to dest
	else:
		move(disk_nr - 1, source, spare, dest)
		move disk from source to dest
		move(disk_nr - 1, spare, dest, source)

move(disk_nr, source, dest, spare)[/color][/code]

[tip]Push register values to the stack to save them before calling a function that changes them.[/tip]


=== levels/The Product of Nibbles ===

$14957949958941* What you did here was actually multiplying two 4 bit numbers. We had the intern scale it up to bytes instead.
$19136817138607* [center]Multiply the 4 bit numbers[/center]
$13549246864135* Bit 0
$14533861483435* Multiplying two 4 bit numbers gives you a 8 bit number. Build a circuit that does this.
$10274387271390* Bit 0
$83694551809785* Multiply {num1} and {num2}


=== components/Input 1 Byte ===

$40943344093513* 8 bit input


=== levels/byte_and ===

$15885763626223* Create a circuit that ANDs two bytes bitwise.


=== components/LessI64 ===

$42718501644862* Less (signed)
$19948786194409* Checks if one input is less than the other


=== components/ByteLessU ===

$68645721548287* Checks if one input is less than the other
$73502755965496* Less (unsigned)


=== main_scripts/functions ===

$11467644007149* Counter {nr}
$72465734060414* Short circuit on wire (output values: {values})
$10533010562232* DELAY SCORE: {delay}
$87591753278764* Reg {nr}
$29169064199243* Output {nr}
$13327741293223* Input {nr}
$32508339206292* GATE SCORE: {gate}


=== ui/toggles/level_log2 ===

$91515053618360* Manual


=== levels/odd_number_of_signals ===

$16173829560311 Используя не более трёх компонентов, установите Вывод в значение [ON], когда количество Вводов [ON] нечётное.
$85589489148198 Использовано \n{nr} из 3 компонетов.
$18288998816979 Для этого уровня есть [color=#e63e5b][url=odd_number]подсказка.[/url][/color] Используйте, если вдруг "застряли".


=== ui/translators/tick ===

$92150881431937* Tick


=== misc/wire_color ===

$78287906849040* Wire color


=== levels/or_gate_3 ===

$15448906128695* Create an OR gate with 3 inputs.


=== components/Shl16 ===

$79406691850426* Shift left
$34287811246049* Shifts the bits of an input left


=== components/Program1Red ===

$26811947547688* Programmable memory component
$55594749714809* Program


=== ui/abbreviated_units ===


NOTE: Instead of writing 5839000, the number turns into 5.8M
$22896492410578* M

NOTE: Instead of writing 5839, the number turns into 5.8K
$84696693690500* K

NOTE: Instead of writing 5839000000, the number turns into 5.8B
$71072134093858* B


=== levels/3_decoder ===

$19231618567710* With 3 bits of input there are 8 combinations. Make a circuit that selects 1 output for each of the 8 combinations. No more or less than 1 bit should be [ON] at a time.
$14293122338496* We had our intern add a "disable" bit to this component. We were tired of looking at him running in circles and were looking for other pointless and tedious tasks to give him.


=== components/RegisterRedPlus ===

$57531353625235* Register


=== components/Counter64 ===

$62528867413395* 64 Bit Counter
$62736827510023* Increments each tick, unless overwritten


=== levels/Storage cracker ===

$11910674853271*
The security access door to the storage room is broken and it keeps locking our old janitor inside.

The door keeps changing the passcode, we need a program that can recover the passcode at any time.
$17462419719036*
The easiest way to find the passcode would be to try all combinations until you find the right one. 
Although the broken mechanism does make a weird beep when your guess is too high, you might be able to use that to your advantage.
$11183892008673* You win this level when you output the correct passcode, no output will fail the level. Additionally, the input will be 1 after a guess that was too high and 0 otherwise.


=== levels/constants ===

$17098439090371*
We need a way to directly move numbers from our program into registers. For this we use the immediate mode (when the two highest bits are [OFF][OFF]).

When in immediate mode the whole byte is interpreted as a number that we [SAVE] into REG 0. This means we can 
[SAVE] any value between 0 and 63.


=== components/BNOT ===

$53686485035156* 8 Bit NOT
$26822227902426* Bitwise negates 8 bits


=== components/Output16 ===

$37381472194529* 16 bit output


=== levels/program ===

$16693098943939*
The [INSTRUCTION] input component has been removed. It has been replaced by a program component. Every tick, use the counter to load the next [INSTRUCTION] from the program's memory.
	
You must use the counter component you unlocked earlier for this level.
$19686277478479* The program is still outputting the first instruction. Did you hook up a counter?


=== components/Ror64 ===

$43920264894591* Rotate right
$49583010717958* Rotates the bits of an input right


=== components/Input 3 ===

$70689623552857* Input


=== levels/Arithmetic Engine ===

$16434409050195*
Add addition and subtraction to your circuit.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/capitalize ===

$14894954428144*
The inputs in this level represent the characters in a list of planet names, encoded as ASCII (see the manual). Each name is separated by a space which has the numeric value 32. Replace the first letter in each word with its uppercase counterpart.
(The possible input characters are a to z lowercase, space, apostrophe and dash)
$13301617098810* We had the intern type out planet names in human script. Unfortunately he forgot to capitalize each name.
$11647445869837* Input: 
$11201813578269* Output: 


=== levels/byte_equal ===

$17156565273196* Output [ON] when both inputs are the same.


=== components/Output32z ===

$73681609562628* Only outputs if the switch pin is [ON]
$92749186427039* 32 bit switched Output


=== components/Rol8 ===

$79612280948390* Rotate left
$55557725551789* Rotates the bits of an input left


=== components/OR ===

$13013154620359*
[ON] when either input is [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell]
[/table]
$97247779246257* OR


=== ui/options/General ===

$36195388998735 Общее


=== components/Clock ===

$72088325385177* Clock


=== components/Xnor ===

$94079327237795* XNOR
$90614106399129*
[ON] when nputs are the same
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]


=== levels/not_gate ===

$19085882338208* [b]Instruction[/b]\nRight click to deselect
$10042327259531* Now that you unlocked the NAND gate, it is time for you to build a circuit.
$14042842216181* Last level you made the table that described the circuit. In this level you build the circuit that matches table.
$10604720087324* [b]Instruction[/b]\nBuild a circuit that makes the table correct.\nClick [i][/i] (Next tick) in the upper left corner to test each combination of inputs.\nYou win the level once both combinations have been tested correct.
$19798729463813*
Using NAND gates, build the NOT gate

Using: [b]NAND gate[/b]
[code]INPUT 1: [OFF][ON][OFF][ON]
INPUT 2: [OFF][OFF][ON][ON]
OUTPUT:  [ON][ON][ON][OFF][/code]

Build: [b]NOT gate[/b]
[code]INPUT 1: [ON][OFF]
OUTPUT:  [OFF][ON][/code]

$18442122157391* [b]Instruction[/b]\nDeselect the component by clicking the background
$12880883686501* [b]Instruction[/b]\nClick on the NAND component on the top right side of the screen and place it
$18780831606716* [b]Instruction[/b]\nClick and drag on the board to add a circuit


=== components/1_decoder ===

$26685462633615* Toggles between two outputs
$98250587600120* 1 Bit decoder


=== components/XOR ===

$86856280609387*
[ON] when nputs are different
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]
$54832952840086* XOR


=== components/Not16 ===

$17394768116288* 16 Bit NOT
$91053300263019* Bitwise negates 16 bits


=== misc/factory ===

$53123649343022* Component Factory


=== levels/registers ===

$10661964231175* I have locked the red components of this level in place, since you always make a mess and don't leave enough space. The mess you make from now on is saved between levels, you no longer get to start fresh each level.
$10211777161405*
These are the bit patterns for each [color=#c54d5e]source[/color] and [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  INPUT 
[ON] [ON] [ON]  UNUSED

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  OUTPUT
[ON] [ON] [ON]  UNUSED

To get a more intuitive understanding of the requirements, click the [INSTRUCTION] icon in the upper left corner.
$15888345020710*
In this level you need to create a circuit which can copy from a [color=#c54d5e]source[/color] to a [color=#e49f44]destination[/color]. 

The instruction byte in this level determines the [color=#c54d5e]source[/color] and the [color=#e49f44]destination[/color]. 

Bits 1, 2 and 3 give the [color=#e49f44]destination[/color]. Bits 4, 5 and 6 give the [color=#c54d5e]source[/color].
$14823499195861* Open "Instructions" in the top bar
$14108238519744* Time to create your master project, implementing the [color=#e49f44]OVERTURE[/color] computer architecture. This will be an actual Turing complete machine, a true computer in every way!
$14411286553593* Finally, the input and output components now have an additional pin. Set that pin [ON] when you want to read from input, or copy to output.
$14041158687959*
[color=#c54d5e]Source[/color] and [color=#e49f44]destination[/color] can be 1 of 6 registers, we will name them REG 0 to REG 5 respectively. 
	
Additionally, this map has a dedicated input component, which can be the [color=#c54d5e]source[/color] and an output component, which can be the [color=#e49f44]destination[/color].


=== components/Output 2 ===

$73255344581755* Output


=== components/Ror16 ===

$13970397213910* Rotates the bits of an input right
$90115282457191* Rotate right


=== components/Nor16 ===

$57921392198825* Bitwise NOR two values
$69522380057631* 16 Bit NOR


=== components/Input 1B CODE ===

$16878300327380* Instruction


=== components/Input32 ===

$10677927084411* 32 bit input


=== components/ON ===

$96212935718484* Always [ON]
$95896157427528* ON


=== ui/top_bar/gate_score ===

$16224450605442* GATE SCORE:


=== misc/level_gate_unlocks_unknown ===

$76731326010721* Unlocks something unknown


=== components/LatencyRam ===

$74156976676497* Latency RAM
$31261866779127* Lowers delay by having save and load take several ticks to complete


=== components/DotMatrixDisplay ===

$18651725958642* 6x8 Dot Matrix Display
$71512568789377* 6x8 pixel display


=== misc/score_sync ===

$76911045833478 Синхронизация Счёта


=== components/Ror32 ===

$84788620524361* Rotate right
$50013003040535* Rotates the bits of an input right


=== components/BOR ===

$19406015796751* Bitwise OR two values
$54190050450484* 8 Bit OR


=== levels/Masking Time ===

$19351773688761* Ticks left: {ticks_left}  Input: {input}
$16810715868480* Calculate modulo 4 of the input.
$17375862136921*
The length of our week is 4 days. Our weekdays are named Zero's day, One's day, Two's day and Three's day. I hear some earthlings number their Two's day incorrectly? 
	
It doesn't really surprise me.
$65431688078892*
In this level you are given a number as input and you should return that number modulo 4 as a result.

The challenge is that you only have {ticks_per_test} ticks to output the desired result.

Note, you don't need to change your hardware, you just have to figure out the trick to do modulo 4 quickly.
Use [color=#e63e5b][url=masking_time]this hint[/url][/color] if you get stuck.
$81055582534899* Anyway new year is coming up and we want you to calculate the weekday of everyone's birthday. We will give you the date and all you have to do is return the weekday within {ticks_per_test} ticks.


=== components/RegisterRed ===

$10081371413873* Register


=== misc/level_gate_manual_icon ===

$22002156022920* Unlocks manual entry


=== components/Console ===

$66743357915699* Console
$16105755937680* 80x24 text character display


=== levels/byte_adder ===

$16888130664370*
If the result does not fit in 8 bits, turn the output carry [ON] (you can think of it as the 9th bit)
	
Finally, there is an input carry as well. This is useful for chaining together byte adders to add larger numbers. You can think of this carry as adding either 0 [OFF] or 1 [ON].

Use [color=#e63e5b][url=byte_adder]this hint[/url][/color] if you get stuck.
$18732877690173* Add the two input bytes. Each output bit in the output should be a result of the addition of the corresponding bits from the inputs, and potentially a carry.


=== components/LessI16 ===

$75600169624828* Less (signed)
$73697238171042* Checks if one input is less than the other


=== components/Shr32 ===

$87104108203785* Shifts the bits of an input right
$88430124157796* Shift right


=== components/ByteLessI ===

$52765625016236* Checks if one input is less than the other
$25403981009644* Less (signed)


=== levels/saving_gracefully ===

$12474728041023
Линия задержки позволяет нам использовать значение на 1 такт позже. 

Нам нужно создать компонент, который позволит нам использовать значение, когда мы захотим, не важно на сколько тактов позже. 
Такое значение называется [color=#e49f44]сохранённым[/color].
$13045361823397 НЕ СОХРАНЯТЬ
$13740696609075
На этом уровне 2 входа.
Только в случве если первый вход [ON], обновите [color=#e49f44]сохранённое[/color] значение.
Второй вход указывает какое значение нужно [color=#e49f44]сохранить[/color].
Всегда выводите [color=#e49f44]сохранённое[/color] значение.
Вот диаграмма компонента который мы хотим построить:

[img]dialogue/saving_gracefully/bit_memory.png[/img]


[color=#e63e5b][url=saving_gracefully]подсказка здесь[/url][/color] если застряните.



=== components/Mux32 ===

$16638728645850* Toggles between two values
$21257226547838* 32 Bit Mux


=== components/BitSwitch ===

$56917313833836* Toggles a bit
$41574334638147* Switch


=== misc/FileInput ===

$28866575833369* Reads bytes from your hard disk
$34159012148766* File Rom


=== components/DelayLine64 ===

$80000130396288* 64 Bit Delay Line
$35525647389906* Outputs this tick's input, next tick


=== components/Nand32 ===

$24565725389553* Bitwise NAND two values
$71611588991682* 32 Bit NAND


=== components/Output32 ===

$37476623180671* 32 bit output


=== misc/profile ===

$32835651830157 Профиль


=== components/Rol32 ===

$88734684504266* Rotates the bits of an input left
$83642246004160* Rotate left


=== components/BeepBox ===

$15009144144117* Waveform Generator


=== components/Bidirectional1 ===

$95836352586032* Can circumvent certain circular dependency errors
$34912798641933* 1 bit bidirectional pin


=== components/Mul32 ===

$98530670555665* Multiply
$51210946736766* Multiplies two inputs


=== components/ByteAnd ===

$61791872137683* Bitwise AND two values
$21541105796357* 8 Bit AND


=== components/Halt ===

$30351143139905* Halt

NOTE: This is the default message of the Halt component
$54106972240596* Halt
$62990744955549* Stops execution with a custom message


=== components/Bidirectional32 ===

$54631386552063* 32 bit bidirectional pin
$35105566244017* Can circumvent certain circular dependency errors


=== components/Counter ===

$51446864816252* Increments each tick, unless overwritten
$67910883947749* 8 Bit Counter


=== misc/specifications ===

$68054407020318* Instructions


=== misc/delete ===

$53448014080434* Delete (Hotkey: Right click)


=== misc/controls2 ===

$38773676077206* Edit Instructions


=== components/Keyboard ===

$40965596602414* Keyboard
$76766452660421* Records keypresses from your physical keyboard


=== components/Input1_1B ===

$10517158300617* Level input
$57868504368581* Loads the input from levels


=== components/NetworkClient ===

$44510554000571* Network
$90462653419289* Handles network connections


=== misc/factory_back ===

$98930461722118* Back


=== levels/unseen_fruit ===

$13023474026617*
The most noteworthy thing on your planet is the fruit. It is very tasty.

That's why we are having a fruit tasting event in the canteen.
$14259900563789* Scan the conveyor belt for the fruit incoming at regular intervals. As soon as you have see the same kind of fruit twice, turn and press the control panel.
$17070232883226* But we want to make sure we don’t get the same fruit twice as that would obviously be embarrassing.


=== ui/toggles/negative_numbers ===

$50924073287410* Toggle number format


=== components/Xnor8 ===

$31985293401482* 8 Bit XNOR
$45789912406647* Bitwise XNOR two values


=== levels/conditions ===

$12951779797594*
This level has a value input and 3 condition bit inputs.

The 3 bits select the condition as shown below. Check the value against the selected condition and output [ON] if it is satisfied and [OFF] otherwise.

Bit code:        Turn [ON] when:[code]
[OFF] [OFF] [OFF]    Never
[OFF] [OFF] [ON]    If value = 0
[OFF] [ON] [OFF]    If value < 0
[OFF] [ON] [ON]    If value ≤ 0
[ON] [OFF] [OFF]    Always
[ON] [OFF] [ON]    If value ≠ 0
[ON] [ON] [OFF]    If value ≥ 0
[ON] [ON] [ON]    If value > 0[/code]
$16407231803964* If VALUE < 0 output [img]dialogue/on.png[/img]
$16742265812068* Regardless of VALUE output [img]dialogue/on.png[/img]
$17616699231679* If VALUE > 0 output [img]dialogue/on.png[/img]
$16632557438774* If VALUE ≠ 0 output [img]dialogue/on.png[/img]
$18234235689107* If VALUE ≥ 0 output [img]dialogue/on.png[/img]
$12429396872036* Regardless of VALUE output [img]dialogue/off.png[/img]
$19014698800906* If VALUE = 0 output [img]dialogue/on.png[/img]
$13680487623452* If VALUE ≤ 0 output [img]dialogue/on.png[/img]
$12706881725738* Your circuit has been saved to the component factory.


=== levels/full_adder ===

$17063157033479
На предыдущем уровне мы суммировали значения двух Вводов, в этот раз мы будем суммировать три. В общем, сложите входные данные в двоичном формате, чтобы результат был либо [ZERO] либо [ONE].

Как и при обычном сложении "столбиком", когда результат не может быть описан одной цифрой, установите перенос (CAR) в значение [ONE].


=== levels/or_gate ===

$12749704931323 Надеемся, вы счастливы, что принимаете участие в наших замечательных испытаниях?
$11472059692644 Взамен Вы получили возможность общаться с очень продвинутыми представителями других цивилизаций, не так ли?


=== components/3_decoder ===

$59129788113517* Toggles between eight outputs
$94375716460090* 3 Bit decoder


=== components/ByteShl ===

$74488427658653* Shift left
$66482114876737* Shifts the bits of an input left


=== components/Counter16 ===

$37313834107391* Increments each tick, unless overwritten
$49104925799943* 16 Bit Counter


=== components/Add16 ===

$28092601427278* Adds two inputs
$30820974870562* Add


=== levels/and_gate ===

$15232844525838
Постройте цепь, которая будет соответствовать таблице.

[tip]Двойное нажатие на компонент позволяет перемещать его вместе с соединениями.[/tip]
$15231724707514 Не хочется делать преждевременных выводов, однако, нам кажется, что, например, слон справится с этой задачей быстрее. Без обид, просто его мозг значительно больше.


=== components/Not32 ===

$33620523355085* 32 Bit NOT
$24607331341411* Bitwise negates 32 bits


=== components/Equal32 ===

$32710942647020* Equal
$32433537137277* Checks if the two inputs are equal


=== components/MemoryProbe ===

$46948613505134* Display a value on your custom component or in the program editor
$44867305035474* Memory Probe


=== misc/factory_back_inner ===

$12211557416281* Back


=== components/Byte Expander ===

$60488114435022* Splits a byte into 8 bits
$21904470559153* Byte Splitter


=== ui/toggles/level_log ===

$38557550573896* Level log


=== misc/StateProbe ===

$54427436420428* Wire Probe
$15969687819995* Display a value on your custom component or in the program editor


=== components/Splitter32 ===

$90978982016052* Splits 32 bits into 4 byts
$24096666569346* 32 bit Splitter


=== misc/change_schematic ===

$79554853897000* Switch schematic


=== levels/sr_latch ===

$11150103897185*
In this level, components may depend on themselves or form loops of up to two components. Despite depending on their own output, some of these wires have stable outputs, at least for some inputs.

The circuit you are asked to construct here has a circular dependency. The circuit also has 2 "stable states" for most inputs. A stable state here means that every component's output agrees with its input. As an example, an OR gate with one input disconnected and the other connected to its own output is stable. If the output is [OFF], both inputs are [OFF], which agrees with the OR gate. If the output is [ON], then so is one of the inputs. However, a NOT gate connected to its own input is not stable. If the output is [ON], then the input is [ON] as well. This will cause the NOT gate to try and make the output [OFF], which will also make the input [OFF]. The circuit will switch between these two states forever, so it is not stable.
$18165461234561* Delay lines are easy to understand and can be used to build any computer architecture. However, modern hardware no longer use these as a basis for memory.
$15754153332116* This level introduces the concept of latches. This mechanic is not necessary to complete the game.
$15213907597666* Using 2 NOR gates, build the circuit that matches the table. You will need a latch.
$19448398663695*
When we want to determine what components in a circular dependency are outputting, we don't have a first component we can start with. Instead we use the values of the wires from last tick. This is because in real hardware electrons don't travel instantly. Depending on the circuit, the wires either flicker between [ON] and [OFF], or settle in a stable state.
	
When you have a circuit where the wires can settle in either of 2 different stable states, you have a basis for memory. The next state will depend on the values the wires had last tick. Such wires are called "latches".


=== components/Program64 ===

$76480303942112* Programmable memory component


=== components/Shl32 ===

$38930281262898* Shift left
$88685329847417* Shifts the bits of an input left


=== components/FastRam ===

$79436020115192* Fast but high gate cost memory
$12924829814634* Fast RAM


=== levels/byte_xor ===

$19636386696963* Create a circuit that XORs two bytes bitwise.


=== components/Shl64 ===

$56766765894165* Shifts the bits of an input left
$37014604954362* Shift left


=== levels/Immediate Values ===

$64348543296709* Watched state {value} should point to the output
$14060810229477* Add 6 registers to the map
$79667526283284* Watched state {value} should point to the counter
$14960344494328*
Sometimes it is useful to load a value directly from the program instead of from registers. This is called loading an immediate value. In the [color=#e49f44]LEG[/color] architecture we signal when we want to do this directly in the opcode. We can do that in the following way:
	
When the 8th bit of the opcode is [ON], use argument 1 as an immediate value, instead of as a register address.
When the 7th bit of the opcode is [ON], use argument 2 as an immediate value, instead of as a register address.
	
		[img]dialogue/leg_diagram.png[/img]
		

$10788301006338* Watched state {nr} should point to a register or custom component with a register inside
$19338533633006* Set the counter increment to 4
$15197362332657* Create a new schematic and add a program with 4 byte output
$18004215603701* Add a counter to the circuit
$10141611261952* [center]Implement immediate values[/center]


=== misc/menu ===

$56916384895438* Main menu


=== levels/xor ===

$11589029892097* XOR the bits of the inputs {a} and {b}
$12758156517177* Using the instructions of your computer, read the input twice and XOR the two values together
$16047615798435* [center]Read the input twice and XOR the bits of the two inputs[/center]


=== components/switch ===

$87345192339084* Toggles a value
$29301846684808* 8 Bit Switch


=== components/Register64 ===

$86007777261800* 64 Bit Register
$99461037008796* 64 bit memory


=== levels/Wire Spaghetti ===

$29329105515650* Add 1 more register to the map
$17106892574116* Add a counter to the circuit
$50177586789991* Add {nr} more registers to the map
$15754373587500* Set the counter increment to 4
$56024330661504* Watched state {nr} should point to a register or custom component with a register inside
$19099471819164*
The following are the set up steps that needs to be done in order to complete this level:
		
[b]1.[/b] Click the schematic icon ([b][i][/i][/b]) and create a new empty architecture.
[b]2.[/b] Place a program block with 4 outputs.
[b]3.[/b] Place a counter, set its increment to 4 and connect it to the program block.
[b]4.[/b] Add 6 registers (or custom components with registers)
[b]5.[/b] Click "Edit watched state" on the program component and connect registers to 0 to 5. Connect the counter to 6 and the output to 7.

$18860645759682*
The [color=#e49f44]LEG[/color] architecture is a computer that takes 4 bytes per tick from the program. 

The first byte describes the operation (called the [color=#e49f44]OPCODE[/color]).

Since many operations take 2 arguments (like ADD, OR etc), the second and third byte are for arguments.

And since most operations return 1 result, the fourth byte is for the result.
	
	[img]dialogue/leg_diagram_1.png[/img]
$11377431500625* Add 6 registers to the map
$14051336765362* Finally it is time for you to start building the [color=#e49f44]LEG[/color] architecture!
$13268807052125* (You might be adding 7+7, but here 7 means load from input and the input has value 8)
$30006055126224* Watched state {output} should point to the output
$19066122929275* [center]Set up registers and implement the ADD opcode[/center]
$10912834168905*
Finally, in this level the [color=#e49f44]OPCODE[/color] is always 0. This means we ADD argument 1 and argument 2 and save the result to the destination.

The value of an argument or destination refers to one of these places:
[code]
[color=#e49f44]0[/color]: Register 0
[color=#e49f44]1[/color]: Register 1
[color=#e49f44]2[/color]: Register 2
[color=#e49f44]3[/color]: Register 3
[color=#e49f44]4[/color]: Register 4
[color=#e49f44]5[/color]: Register 5
[color=#e49f44]6[/color]: Counter
[color=#e49f44]7[/color]: Input/Output
[/code]

In the next level you will implement more [color=#e49f44]OPCODES[/color], which will require a different ALU than that of [color=#e49f44]OVERTURE[/color].


$10922418807673* Argument 7 means read from input, but input is not enabled.
$62258842382434* Watched state {counter} should point to the counter
$18769284297247* Create a new schematic and add a program with 4 byte output


=== components/Neg32 ===

$26991597084705* Negate
$35735598635057* Bitwise negates an input


=== components/InputConditions ===

$75386511637758* Input


=== levels/the_bus ===

$72472660427162* [center]Copy the value from input {input_nr} to output {output_nr}[/center]
$85140574084420* [center]Copy the value from the correct input to the correct output[/center]


=== components/Ram ===

$95418291334002* 256 Byte Ram
$27094240214067* Memory component


=== components/Constant16 ===

$85825068431072* 16 Bit Constant
$61330657823382* Constant value


=== levels/and_gate_3 ===

$14788981567936 Создайте компонент AND с тремя входами(3 inputs).


=== components/Output8zLevel ===

$49513138880387* Output


